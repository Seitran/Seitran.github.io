<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"seitran.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="码农的午后抒怀">
<meta property="og:type" content="website">
<meta property="og:title" content="Chenny的Blog">
<meta property="og:url" content="http://seitran.com/index.html">
<meta property="og:site_name" content="Chenny的Blog">
<meta property="og:description" content="码农的午后抒怀">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chenny Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://seitran.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chenny的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chenny的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">All the SECRETS are behind the SOURCE CODE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2020/04/06/0031-virtualization-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/0031-virtualization-summary/" class="post-title-link" itemprop="url">虚拟化技术综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-06 19:58:35 / 修改时间：20:16:03" itemprop="dateCreated datePublished" datetime="2020-04-06T19:58:35+08:00">2020-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">技术分享</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作当中接触了挺多的虚拟化内容，同时也自学了不少的技术文章，趁这个机会，把虚拟化相关的内容总结下来，作为后面的知识查阅。</p>
<p>本文的内容有许多来源：一部分是网上现有的材料，加以总结和概述，这部分都会在文章最后以参考、引用的形式体现；另一部分是自己工作中接触到的知识以及自己的理解，这部分可能受限于自己的学识和理解，有可能存在谬误，希望读者能够指出。</p>
<p>虚拟化的缘由：<br>单系统能力的不断提升，基础设施的云化创造了虚拟化的商业基础。</p>
<p>虚拟化主要包括了三部分：CPU的虚拟化，内存的虚拟化和IO设备的虚拟化。</p>
<p>单host上虚拟化出来的guest os会共同share一套硬件。guest会分给不同的用户，某个guest不应感知到其他的guest，它们应该是独立的，不会相互影响。这就要求了hypervisor提供一套机制，来保证不同的guest相互隔离。</p>
<p>当前的发展趋势一般是：软件实现-&gt;性能较低-&gt;不断的高性能需求-&gt;硬件提供加速功能-&gt;硬件卸载这样一套逻辑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2019/11/29/0029-understand-interrupts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/29/0029-understand-interrupts/" class="post-title-link" itemprop="url">对中断的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-29 20:57:30 / 修改时间：21:44:16" itemprop="dateCreated datePublished" datetime="2019-11-29T20:57:30+08:00">2019-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近花了一定的时间，把之前一直概念比较模糊的中断、vector、irq等概念搞清楚了。这里简单记录一下。其中对应比较硬件的部分描述不是特别准确，仅作基本原理性的阐述。</p>
<p>在之前上大学的时候，一直提及一个概念，IRQ（interrupt request），大学里学的IRQ实际上是物理上的信号线，而Linux系统中同样有IRQ的概念，而这个IRQ，实际上是一个纯软件的定义。每次到这里的时候都搞得比较晕。</p>
<p>在现代的X86系统中，外部设备的中断依然还要通过信号线接到中断控制器上（通过中断管脚INTx），进而到达CPU，产生中断事件。传统的中断方式，在系统上电后，会由bios分配一个全局的GSI号，Linux启动后，会从bios中读取GSI号保存下来。在设备驱动加载初始化时，会对其分配vector和irq；配置REDIR_TBL表项，写入IO_APIC中断控制器，确定此设备的GSI号和vector的对应关系。</p>
<p>中断的过程：外设产生中断-&gt;传递到IO_APIC对应的IRQ_PIN管脚-&gt;IO_APIC将REDIR_TBL中相应的entry发送到处理器-&gt;处理器获取vector-&gt;处理器获取irq-&gt;处理器执行对应的irq_handler；</p>
<p>对于使用MSI/MSI-X设备来讲，设备（主要指PCIe设备），中断实际上是发送相应的TLP报文到中断的地址上，涉及到的是message data和message address。其中，message data中就包含了vector的信息。</p>
<p>中断的过程：外设选择message data和message address，决定发哪个中断-&gt;发送TLP报文-&gt;目标CPU接收到这个memory write事务-&gt;识别成中断-&gt;提取vector-&gt;获取irq-&gt;调用irq_handler。</p>
<p>而vector和irq的关系是：每个CPU都会保存一个vector-irq的映射，也就是vector和irq是对应的。对当前的intel x86 来讲，一个CPU有256个vector。一个系统中，有多少个CPU，也就是有多少个vector；irq的数目，和系统中所有的vector数目是对应的。比如，系统中8个cpu，一般来讲，可以有irq的总数是8 * 256个；但是因为系统会固定占据一些irq，这样会导致外设能够分配和使用irq，比8 * 256要少。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2019/01/02/0028-new-year-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/02/0028-new-year-summary/" class="post-title-link" itemprop="url">2018年总结和2019年展望</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-02 21:41:47" itemprop="dateCreated datePublished" datetime="2019-01-02T21:41:47+08:00">2019-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-29 20:48:54" itemprop="dateModified" datetime="2019-11-29T20:48:54+08:00">2019-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/" itemprop="url" rel="index"><span itemprop="name">个人感悟</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>工作的原因，很久没有更新过博客了。最近一段时间，经历了许许多多的事情，开心的有，伤心的也有。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/11/16/0027-TCP-single-flow-performance-issuse-focus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/16/0027-TCP-single-flow-performance-issuse-focus/" class="post-title-link" itemprop="url">单流TSO发送性能波动问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-16 22:11:57" itemprop="dateCreated datePublished" datetime="2017-11-16T22:11:57+08:00">2017-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-29 20:49:23" itemprop="dateModified" datetime="2019-11-29T20:49:23+08:00">2019-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天遇到了一个问题：redhat 7.1上，两张网卡，姑且称之为卡H和卡A。卡H作为client，卡A作为Server，运行iperf测试工具进行单流的TCP测试。出现了周期性的带宽波动，本文记录下定位过程，涉及到对内核代码和工具的简略探究。</p>
<p>卡H的TSO功能已经开启，卡H和卡A均进行了中断绑定，已经可以避免因为进程或者中断在不同的CPU core上迁移导致的带宽不稳。</p>
<p>netstat -s可以查看整个系统的网络部分的统计。netstat -s | grep ret可以看到Retransmit重传的信息。观察到一个现象：随着带宽的下降，卡H侧的服务器出现了快速重传，没有出现超时重传。</p>
<p>快速重传意味着带宽会有下降，一般是由于发出去的报文出现了丢包或者乱序。乱序的可能性不大，主要是丢包。因为两台服务器是直连，丢包的位置只能是卡A侧的服务器，或者是卡A本身，或者是协议栈。ethtool -S可以看到网卡相关的统计，grep出drop相关的统计，并没有发现有drop，进而需要查看协议栈是否有丢包。ifconfig可以看到rx dropped的统计。发现随着带宽的下降，rx dropped的统计也在增加。</p>
<p>说明性能下降的原因的确就是报文被drop。那么协议栈为什么会drop部分报文呢？直觉上有两种可能：协议栈处理能力不够，或者是报文本身错误。如果我们稍微较小一点的带宽进行发送，没有出现波动，那么说明报文本身出错的可能性比较小，很大的可能是协议栈处理能力不够。怎么证明这一点呢？show the code。</p>
<p>首先，ifconfig本身是一个工具，随着redhat的发行版一起发布。但是没有相应的源代码，我们就需要在网上找到src.rpm（ifconfig在redhat里面应该是随着nettools包一起的，关键词带上net tools，加上uname -a里面查询到的版本号，再加上src rpm，就能找到相关的源码包。yum -ivh xxx.rpm，可以生成rpmbuild/SOURCE。rpmbuild的目录可能不好找，只需要find / -name “rpmbuild”一下找到对应位置即可。SOURCE下面就有tar.xz，这个就是有源码了）。</p>
<p>查看源码可以知道，是从/proc/net/dev获取的信息，而内核怎么写到这个文件中的呢？再检索一下，内核是通过proc-fs写入的。看相应的内核源码，统计值是从netdev的stats中获取。而stats的rx dropped有两个来源，一个是rx missed error，这个统计来源于网卡驱动设备，另外一个rx dropped在内核代码中检索，可以看到几处对其进行增加的位置，可以发现要么是申请内存失败时增加，要么是把报文加入backlog中失败后增加。而更大可能是backlog队列满导致的报文被丢弃。</p>
<p>原因基本明了。由于时间仓促，源码也来不及贴入，不过不影响定位思路阐明。完。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/11/15/0026-DPDK-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/15/0026-DPDK-overview/" class="post-title-link" itemprop="url">DPDK基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-15 22:09:24" itemprop="dateCreated datePublished" datetime="2017-11-15T22:09:24+08:00">2017-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-12-19 22:31:18" itemprop="dateModified" datetime="2017-12-19T22:31:18+08:00">2017-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DPDK/" itemprop="url" rel="index"><span itemprop="name">DPDK</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DPDK是数据平面开发工具包。将数据收发从内核态移动到用户态，以实现高速的报文收发能力。</p>
<p>环境抽象层（Eniveronment Abstraction Layer）为DPDK的库和应用提供了与具体硬件无关的通用接口。</p>
<p>它能够提供的几大功能：</p>
<p>DPDK加载启动、多核多线程支持、CPU亲和性、系统内存申请释放、原子操作、时钟、PCI总线访问、追踪调试、CPU特性识别、中断处理、告警和内存管理。</p>
<p>DPDK的核心组件是一组库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/10/15/0025-network-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/15/0025-network-performance/" class="post-title-link" itemprop="url">19-network-performance</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 12:27:27" itemprop="dateCreated datePublished" datetime="2017-10-15T12:27:27+08:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-10 20:33:59" itemprop="dateModified" datetime="2020-04-10T20:33:59+08:00">2020-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>网络性能的优化是一个很大的主题，一两篇文章很难说的清楚，在这篇文章中，我简单阐述一些性能调优、性能问题定位时候的一些关键思路。</p>
<p>所谓网络性能，实际上对计算机而言，也是属于IO领域。反映网络性能的3个关键指标是：时延、带宽、包率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/10/15/0024-SSE-AVX-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/15/0024-SSE-AVX-summary/" class="post-title-link" itemprop="url">Intel的扩展指令集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 12:27:11" itemprop="dateCreated datePublished" datetime="2017-10-15T12:27:11+08:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-29 20:47:05" itemprop="dateModified" datetime="2019-11-29T20:47:05+08:00">2019-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/08/03/0023-DMA-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/03/0023-DMA-summary/" class="post-title-link" itemprop="url">DMA学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-03 23:08:40" itemprop="dateCreated datePublished" datetime="2017-08-03T23:08:40+08:00">2017-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-11-15 22:16:20" itemprop="dateModified" datetime="2017-11-15T22:16:20+08:00">2017-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从大学本科开始就接触了DMA的概念，但没有系统的总结过。结合工作的经验，以及内核相关文档，便有了这份总结。</p>
<p>教课书中的概念就不再赘述了。DMA实际上是赋予了设备在CPU的控制下，对memory进行读写访问的的能力。所谓的“CPU的控制”，指的是控制路径，CPU/软件当然要对DMA的地址、长度进行设置，对不同的设备的DMA空间进行隔离等；而实际的DMA动作，则是by pass CPU的。</p>
<p>谈到DMA，不可避免的会涉及到不同的地址转换，这对理解Linux下面的DMA是十分重要的。总共有三类地址：虚拟地址，物理地址以及总线地址。</p>
<p>内核通常使用<strong>虚拟地址</strong>，比如像<em>kmallc()</em>，<em>vmalloc()</em>和类似的接口返回的地址都是void *类型的虚拟地址。</p>
<p>虚拟内存系统，比如TLB，页表等，会将虚拟地址转换成CPU的物理地址。物理地址的类型一般为phy_addr_t或者resource_size_t。外设的寄存器，内核实际上是把它们当成物理地址来进行管理，这些地址可以在/proc/iomem中被访问。这些物理地址不能直接被驱动程序使用，必须使用ioremap()来将这些地址映射为虚拟地址之后，才能被驱动所使用。这也就是为什么我们的驱动程序中，总是会看到设备的寄存器地址空间被ioremap后，才能被正确访问。</p>
<p>对于IO设备来讲，它们使用的地址通常被称为总线地址（bus address）。如果设备的寄存器在MMIO地址空间，或者它使用DMA对memory进行读写访问，这个过程中设备所使用的地址其实就是总线地址。在一些硬件架构中，总线地址和CPU的物理地址是相同的，但是并不是所有的都这样。IOMMU和host bridge可以在总线地址和物理地址之间进行任意的映射。</p>
<p>从设备的角度来讲，DMA使用总线地址空间或者总线地址空间的一个子集。比如说，虽然系统支持64-bit的地址空间，但是经过IOMMU，设备可能仅仅使用32-bit的地址空间就可以了。</p>
<img src="/images/17_1.png" class="" width="400" height="600" title="一个地址转换的示例">

<p>在枚举过程中，内核会获取到IO设备、它们的MMIO空间以及所挂载的桥设备。例如，一个PCI设备有BAR空间，内核从BAR空间中拿到总线地址（A)，并且将它转换成CPU物理地址（B）。地址（B）被存储在struct resource结构中，并且通过/proc/iomem暴露出来。当驱动probe设备的时候，通常会用ioremap()来讲物理地址（B）映射成虚拟地址（C)。此时，就可以通过类似ioread32（C)来访问到设备在总线地址（A)上的寄存器。</p>
<p>驱动程序同样的，可以使用kmalloc()和类似的接口，来分配一个buffer。接口返回的地址实际上是虚拟地址，如虚拟地址（X)。虚拟内存系统将X映射到物理地址（Y)。驱动可以使用虚拟地址（X)来访问这个buffer，但是设备不能使用这个地址，因为DMA不会经过CPU的虚拟内存系统。</p>
<p>在一些简单的系统中，设备可以直接向屋里地址Y进行DMA访问。但是在其他的系统中，一般需要一种硬件，比如IOMMU，建立DMA地址（总线地址）和物理地址的映射关系。比如，将地址（Z）转换成地址（Y)。dma_map_single()接口其实就是做了这么一个事情：传入了虚拟地址X，然后设置IOMMU映射，然后返回了总线地址（DMA地址）Z。映射之后，驱动就可以告诉设备使用地址（Z)进行DMA，IOMMU会将对这个地址的DMA操作映射到实际的RAM中的地址Y上。</p>
<p>Linux系统也能支持动态DMA映射，驱动只需要在地址实际使用之前进行mapping，在使用之后进行unmap即可。</p>
<h2 id="DMA相关的API"><a href="#DMA相关的API" class="headerlink" title="DMA相关的API"></a>DMA相关的API</h2><p>DMA相关的API与底层的架构无关，因为Linux已经替我们做好了HAL层。所以我们使用DMA API的使用，不应该使用总线相关的API，比如使用dma_map_<em>()，而非pci_map_</em>()接口。</p>
<p>在我们的驱动程序里，应该包含头文件linux/dma-mapping.h，这个头文件提供了dma_addr_t的定义。dma_addr_t可以提供对任何平台的dma地址的支持。</p>
<h2 id="内存的DMA可用性"><a href="#内存的DMA可用性" class="headerlink" title="内存的DMA可用性"></a>内存的DMA可用性</h2><p>哪些内存可以被用作DMA？有一些不成文的规则。</p>
<p>使用页面分配函数（比如__get_gree_page*())或者通用内存分配函数（比如kmalloc()、kmem_cache_alloc()）分配的地址一般是可以来用作DMA地址的。</p>
<p>而使用vmallc()函数分配的地址最好不要用作DMA，因为vmalloc分配出来的地址在物理地址上不一定连续，进行DMA的时候可能需要遍历页表去拿到物理地址，而将这些物理地址转成虚拟地址的时候，又需要使用到__va（）类似的函数。</p>
<p>所以，我们一般不能使用内核镜像地址（比如data/text/bss段），或者模块镜像地址、栈地址来进行DMA，这些地址可能被映射到物理内存上的任意位置。即使我们要使用这些种类的地址来进行DMA，我们也需要确保I/O buffer是cacheline对齐的。否则，就很容易在DMA-incoherent cache上出现cache一致性的问题。</p>
<p>我们也不能使用kmap()返回的地址来进行DMA，原因与vmalloc()类似。</p>
<p>块I/O和网络设备的buffer怎么分配的呢？实际上，块I/O和网络子系统会保证它们使用的地址是可以进行DMA的。</p>
<h2 id="DMA地址的限制"><a href="#DMA地址的限制" class="headerlink" title="DMA地址的限制"></a>DMA地址的限制</h2><p>设备对于DMA地址空间一般都有一定的限制，比如说我们的设备的寻址能力只有24bit，那么我们一定要将限制通知到内核。</p>
<p>默认情况下，内核认为设备的寻址空间可以达到32bit。对于有64bit寻址能力的设备来讲，我们需要告知内核调大这个能力。而对于不足32bit寻址能力的设备来讲，需要告诉内核降低这个能力。</p>
<p>需要特别注意的一点是：PCI-X规范要求PCI-X设备要能够支持64-bit的寻址（DAC）的数据传输。并且某些平台（SGI SN2）也要求当IO总线是PCI-X模式时，必须要支持64bit的consistent分配。</p>
<p>正确的操作应该是：我们必须在设备的probe函数中向内核查询机器的DMA控制器能否正常支持当前设备的DMA寻址限制。即使设备支持默认的设置，我们最好也在probe函数中这么做。起码说明我们考虑到了这个事情。</p>
<p>通过调用dma_set_mask_and_coherent()可以完成这种能力通知：函数原型为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask_and_coherent</span><span class="params">(struct device *dev, u64 mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以同时通知streaming和coherent DMA的寻址能力。如果有特殊的需求的话，也可以使用下面两个单独的查询函数：</p>
<p>设置streaming DMA的能力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask</span><span class="params">(struct device *dev, u64 mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设置consistent DMA的能力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_coherent_mask</span><span class="params">(struct device *dev, u64 mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这些函数中，dev指向设备所对应的struct device结构体，mask是一个bit域的mask值，用来描述设备支持哪些bit位宽的寻址能力。如果这个函数返回了0，则表示设备能够在当前的机器上正常的DMA。通常情况下，设备的struct device结构体会嵌入在设备的总线相关的struct device结构体中。比如，&amp;pdev-&gt;dev是一个指向我们的设备，我们的设备是挂载到PCI上，而pdev则是指向了我们设备的PCI struct device结构体。</p>
<p>如果返回值不是0，那么表明我们设备在这个平台上不能正常的完成DMA操作，如果强行做的话，会导致不可预期的结果。要么我们使用不同的mask掩码，要么不要使用DMA。</p>
<p>这意味着当上面三个函数返回失败后，我们可以做如下几个事情：</p>
<ol>
<li>如果可能的话，使用其他的mask掩码</li>
<li>如果可能的话，在数据传输时，使用非DMA方式</li>
<li>忽略这个设备，并且不初始化它（不使用这个设备了）</li>
</ol>
<p>当出现第2点和第3点的时候，建议使用KERN_WARNING级别的打印来输出一条消息。这样以来，当用户使用我们的设备时发现有问题或者设备不能被检测到时，可以通过内核打印来找到原因。</p>
<p>对于标准的32bit寻址能力的设备，可以使用如下的代码进行设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="number">32</span>))) &#123;</span><br><span class="line">  	dev_warn(dev, <span class="string">"mydev: No suitable DMA available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于具有64bit寻址能力的设备来讲，我们一般首先会尝试设置64bit的寻址能力，但是如果返回失败的话，则会尝试32bit的寻址能力。通常情况下，之所以会设置64bit寻址能力失败，可能仅仅是因为32bit的寻址能力相对于64bit的寻址能力更加高效。比如，在Sparc64中，PCI SAC寻址比DAC寻址更快。</p>
<p>以具有64bit寻址能力的设备设置streaming DMA能力为例，可以使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> using_dac;</span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="number">64</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="number">32</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dev_warn(dev, <span class="string">"mydev: No suitable DMA available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果也要设置consistent DMA能力的话，则使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> using_dac, consistent_using_dac;</span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MSAK(<span class="number">64</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">1</span>;</span><br><span class="line">  	consistent_using_dac = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="number">32</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">0</span>;</span><br><span class="line">  	consistent_using_dac = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dev_warn(dev, <span class="string">"mydev: No suitable DMA available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>coherent  DMA的掩码与streaming DMA的mask相等或者要小一些。极少数的设备只支持consistent分配，那么我们就必须使用检查dma_set_coherent_mask()的返回值。</p>
<p>最后，如果设备支持24bit的寻址空间的话，我们需要这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="number">24</span>))) &#123;</span><br><span class="line">    dev_warn(dev, <span class="string">"mydev: 24-bit DMA addressing not available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当dma_set_mask()或者dma_set_mask_and_coherent()成功（返回值为0）的话，内核会将我们提供的mask信息保存下来，并在后续做DMA mapping的时候使用。</p>
<p>还有一种比较特殊的场景需要考虑，比如说设备支持多个功能（如一个声卡支持播放和录音功能），不同的功能有不同的DMA寻址限制。这时我们希望在probe的时候能够针对不同功能设置合适的mask掩码。但实际上，只有最后一次调用的dma_set_mask()才生效。下面是一份伪代码来描述这种场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYBACK_ADDDRESS_BITS	DMA_BIT_MASK(32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_ADDRESS_BITS		DMA_BIT_MASK(24)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, PLAYBACK_ADDRESS_BITS)) &#123;</span><br><span class="line">    card-&gt;playback_enabled = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    card-&gt;playback_enabled = <span class="number">0</span>;</span><br><span class="line">  	dev_warn(dev, <span class="string">"%s: Playback disabled due to DMA limiatations.\n"</span>, card-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, RECORD_ADDRESS_BITS)) &#123;</span><br><span class="line">  	card-&gt;record_enabled = <span class="number">1</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    card-&gt;record_enabled = <span class="number">0</span>;</span><br><span class="line">  	dev_warn(dev, <span class="string">"%s: Record disabled due to DMA limiations.\n"</span>, card-&gt;name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子使用的声卡设备如果是PCI设备的话，其实就像是ISA标准残留下来的“垃圾”，因为这种设备还保持着ISA标准所具有的16M的DMA寻址空间限制。</p>
<h2 id="两种类型的DMA映射"><a href="#两种类型的DMA映射" class="headerlink" title="两种类型的DMA映射"></a>两种类型的DMA映射</h2><p>一般有两种类型的DMA映射：</p>
<h3 id="一致性DMA映射（consistent-DMA）"><a href="#一致性DMA映射（consistent-DMA）" class="headerlink" title="一致性DMA映射（consistent DMA）"></a>一致性DMA映射（consistent DMA）</h3><p>这种类型的DMA通常是在驱动初始化的时候进行映射。在驱动卸载时候进行unmap。硬件应该保证设备和CPU可以并发的访问DMA数据。不需要显示的进行数据flush，任何一方都可以看到另外一方写入的最新数据。consistent DMA也可以理解成synchronous或者coherent。当前默认会将consistent DMA申请的内存放在低32bit寻址的空间内，但是为了以后的兼容性，即使当前的默认值对于我们的设备也ok，我们写驱动程序的时候，还是应该显示地进行一致性DMA mask的设置。</p>
<p>经常使用consistent映射的一些场景包括：</p>
<ul>
<li>网卡设备的DMA ring环描述符</li>
<li>SCSI适配器的mailbox的命令数据结构</li>
<li>设备主存放不下的设备固件微码</li>
</ul>
<p>上面描述的这三种应用场景都要求CPU对于DMA内存的修改都可以立刻被设备看到，设备对于DMA内存的修改也可以被CPU立刻看到。consisitent DMA映射可以保证这一点。</p>
<p><strong>特别需要注意的一点是</strong>，一致性DMA不能提供相关的内存屏障。现代CPU一般都可能将指令打乱以提高指令执行的性能，而这些被打乱的指令里面一旦有访问一致性DMA的store/load等指令时，情况就会变得很微妙。比如说有一个描述符，word0中的内容必须先被更新，word1的内容一定要后被更新。那么我们必须写类似于下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc-&gt;word0 = address;</span><br><span class="line">wmb();</span><br><span class="line">desc-&gt;word1 = DESC_VALID;</span><br></pre></td></tr></table></figure>

<p>内存屏障之前的指令一定会先于内存屏障之后的指令执行。因此上面的这段代码保证了在使能desc之前，就将地址放入word0中。值得一提的是，wmb是一个与平台无关的内存屏障，这样就保证了代码在任何平台上都能得到正确的结果。</p>
<p>在一些平台上，我们可能需要刷新CPU的写buffer或者PCI桥的写buffer。通常的做法是在写操作之后加一个读操作。</p>
<h3 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h3><p>流式DMA映射一般用在一次DMA传送过程中，使用完即可unmap（除非使用了dma_sync_*）。硬件可以对这种DMA映射的访问进行顺序访问的优化。</p>
<p>可以将“streaming”理解成“异步的”（asynchronous）或者“非一致性的”（outside the coherency domain）。</p>
<p>经常使用流式DMA的一些场景包括</p>
<ul>
<li>网络设备的发送/接收buffer；</li>
<li>SCSI设备的文件系统的读写buffer。</li>
</ul>
<p>流式DMA映射的接口设计，允许具体的实现可以进行任何硬件设备所允许的优化。最后，使用这类映射时，我们需要对自己想要什么样的结果十分清楚。</p>
<p>任何一种类型的DMA映射都不会因为底层的总线类型而产生一些字节对齐的限制，也许某些设备本身会有类似的限制。</p>
<p>同时，在具有cache功能的平台上，当DMA buffer没有和其他数据产生冲突（在同一个cache line）时，这个时候的DMA性能是最高的。</p>
<h2 id="使用一致性DMA映射"><a href="#使用一致性DMA映射" class="headerlink" title="使用一致性DMA映射"></a>使用一致性DMA映射</h2><p>如果想要分配和映射大（PAGE_SIZE或者更大的）的一致性DMA区域，我们应该使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dma_addr_t</span> dma_handle;</span><br><span class="line">cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);</span><br></pre></td></tr></table></figure>

<p>dev是一个struct device *类型的变量，这个函数可以在中断上下文中被调用，只要使用了GFP_ATOMIC标志。size是我们要分配的区域大小，单位是Byte。</p>
<p>该函数会在RAM中分配相应的空间，它表现和__get_free_pages()的行为很相似（参数有些区别，比如size表示字节数，而get_free_pages则是指数次幂）。如果设备想分配的区域小于1个page，使用dma_poll相关的接口会更好一些。</p>
<p>一致性DMA映射的接口，当dev非空时，默认情况下会返回一个32bit寻址范围内的DMA地址。当设备显式地调用dma_set_coherent_mask来设置DMA掩码的时候，这个接口对一致性DMA映射的函数分配才会返回大于32bit寻址范围外的地址。dma_pool的接口也是类似的。</p>
<p>dma_alloc_coherent()会返回两个值：通过CPU可以访问的虚拟地址以及可以传递给硬件的dma_handler。这两个地址还有一个特点：他们都被对齐到PAGE_SIZE的2的指数次幂。</p>
<p>可以使用如下接口进行unmap操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_free_coherent(dev, size, cpu_addr, dma_handle);</span><br></pre></td></tr></table></figure>

<p>接口中dev、size和之前的入参一致，而cpu_addr、dma_handle是alloc函数的返回值。这个函数也可以在中断上下文中被调用。</p>
<p>如果我们需要少量的内存的话，我们可以自己写代码来利用dma_alloc_coherent()返回的地址作为内存池，也可以使用dma_pool接口来做这样的事情。dma_poll类似于kmem_cache，不同的是dma_pool利用的是dma_alloc_coherentl来进行内存分配，而kmem_cache利用的是__get_free_page进行内存分配。此外，dma_pool也会考虑到一些硬件对齐上的限制。</p>
<p>可以使用如下接口来创建一个dma_pool：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">poll = dma_pool_create(name, dev, size, align, boundary);</span><br></pre></td></tr></table></figure>

<p>参数name就是一个名字咯，dev和size与上面都一样。设备的对齐的硬件限制就可以通过align来告诉内核。align必须是2的整数次幂，以byte为单位。如果设备没有对齐的限制，则可以传入0；如果传入4096，则是告诉内核，该pool中的地址不能跨越4K Byte边界，但是在这种场景直接使用dma_alloc_coherent会更好一些。</p>
<p>申请好pool之后，可以使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu_addr = dma_pool_alloc(pool, flags, &amp; dma_handle);</span><br></pre></td></tr></table></figure>

<p>来完成DMA内存申请。flags可以使用GFP_KERNEL（如果允许阻塞）、GFP_ATOMIC等。类似于dma_alloc_coherent()，本函数返回2个值：cpu_addr和dma_handle。</p>
<p>如果要释放从dma_pool中申请的内存，可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_pool_free(pool, cpu_addr, dma_handle);</span><br></pre></td></tr></table></figure>

<p>pool同dma_pool_alloc中传入的pool一致，cpu_addr和dma_handle是dma_pool_alloc返回的对应值。这个函数可以在中断上下文中被调用。</p>
<p>如果要注销dma_pool，可以使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_pool_destroy(pool);</span><br></pre></td></tr></table></figure>

<p>需要在调用这个函数之前，保证从pool中申请的内存都已经被释放完成。这个函数不能在中断上下文中被调用。</p>
<h2 id="DMA方向"><a href="#DMA方向" class="headerlink" title="DMA方向"></a>DMA方向</h2><p>部分的DMA接口函数中，有参数来描述DMA的方向（这个参数在后面会看到），参数是一个整数，并且只能够取如下几个值：</p>
<ul>
<li>DMA_BIDIRECTIONAL</li>
<li>DMA_TO_DEVICE</li>
<li>DMA_FROM_DEVICE</li>
<li>DMA_NONE</li>
</ul>
<p>如果调用函数的时候知道DMA的方向，那么就需要向函数调用提供准确的值。</p>
<p>DMA_TO_DEVICE表示数据传输从主存到设备，而DMA_FROM_DEVICE表示数据传输从设备到主存。</p>
<p>我们需要准确地提供这个值。如果我们实在不知道或者无法确定，那么可以使用DMA_BIDIRECTIONAL。这个参数表示DMA传输可以是任何一个方向。平台可以保证我们这样做且能够正常工作，但是是以性能为代价的。</p>
<p>DMA_NONE是用来调试的。在知道准确方向之前，我们可以将对应的结构体中的值保存为DMA_NONE。一旦因此程序fail的话，可以捕捉到这部分的异常逻辑并进行修复。</p>
<p>这个值还有一个作用是可以用来debug（这个与上一段中的debug不同）。某些硬件平台上，，可以对DMA映射的地址是否可写进行标注，类似于用户地址空间中的页保护。因此，恰当的标注和DMA方向不匹配时，硬件可以捕获这个错误然后上报，进行更深度的DMA保护。</p>
<p>streaming映射需要指定一个方向，而一致性DMA映射不需要指定方向，一致性DMA映射隐含着DMA_BIDIRECTIONAL属性。</p>
<p>在SCSI子系统中，使用SCSI命令中的sc_data_direction来表示DMA的实际方向。</p>
<p>对于网络设备驱动来讲，就更简单了。发送报文时，使用DMA_TO_DEVICE方向来进行map/unmap。而接收报文时，使用DMA_FROM_DEVICE来进行map/unmap。</p>
<h2 id="使用流式DMA映射"><a href="#使用流式DMA映射" class="headerlink" title="使用流式DMA映射"></a>使用流式DMA映射</h2><p>流式DMA映射函数可以在中断上下文中被调用，它有大类map/unmap函数族，一类是映射单个DMA区域，另外一个则是映射DMA地址链。</p>
<p>下面是一个映射单个DMA region的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">my_dev</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">dma_addr_t</span> dma_handle;</span><br><span class="line"><span class="keyword">void</span> *addr = buffer-&gt;ptr;</span><br><span class="line"><span class="keyword">size_t</span> size = buffer-&gt;len;</span><br><span class="line"></span><br><span class="line">dma_handle = dma_map_single(dev, addr, size, direction);</span><br><span class="line"><span class="keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">   * delay and try again later or</span></span><br><span class="line"><span class="comment">   * reset driver.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">goto</span> map_error_handling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是unmap的示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_single(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>调用dma_map_single()后，需要使用dma_mapping_error()来进行检测。这样做是为了保证映射的代码不依赖于某个平台的具体DMA实现。不检测的话，会带来预期意外的问题。dma_map_page()也是一样的。</p>
<p>DMA完成后，要使用dma_unmap_single()来释放，比如在通知host DMA已经完成的中断中来调用这个函数去释放相应的DMA区域。</p>
<p>使用这类的DMA映射具有一个缺点：我们不能引用到HIGHMEM的内存。为了访问HIGHMEM的内存，可以使用另外一组直接操作page/offset的DMA map/unmap函数。下面是使用这组函数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">my_dev</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">dma_addr_t</span> dma_handle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">buffer</span>-&gt;<span class="title">page</span>;</span> </span><br><span class="line"><span class="keyword">size_t</span> size = buffer-&gt;len;</span><br><span class="line"></span><br><span class="line">dma_handle = dma_map_page(dev, page, offset, size, direction);</span><br><span class="line"><span class="keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">     * delay and try again later or </span></span><br><span class="line"><span class="comment">     * reset driver.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="keyword">goto</span> map_error_handling;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">dma_unmap_page(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>这里面，offset指的是页内的偏移。同样的，要使用dma_mapping_error来检查是否映射出错。使用完DMA映射后，调用dma_unmap_page来进行资源释放。</p>
<p>如果使用scatterlists，可以使用如下代码来进行DMA映射：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, count = dma_map_sg(dev, sglist, nents, direction);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span>, *<span class="title">sg</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_sg(sglist, sg, count, i) &#123;</span><br><span class="line">    hw_address[i] = sg_dma_address(sg);</span><br><span class="line">  	hw_len[i] = sg_dma_len(sg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，nents是sglist中地址的个数。</p>
<p>dma_map_sg函数的具体实现，可以将多个sglist项映射成1个DMA映射地址，并且返回映射后的实际地址个数，如果出错的话，则返回0。这对于不能处理scatter-gather或者能够处理的scatter-gather中地址项数有限的硬件来说，是十分有帮助的。</p>
<p>如上suoshu，返回的count一定小于等于nents的值。</p>
<p>如果要释放scatterlist的DMA映射，只需要调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_sg(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，dma_unmap_sg传入的参数nents，与dma_map_sg传入的nents值需要相同，而非dma_map_sg返回的实际映射出来的DMA地址个数。</p>
<p>另外，用完DMA映射后，一定要进行unmap。否则会造成资源泄露。</p>
<p>在使用流式DMA映射地址时，一定要注意数据的同步，以保证CPU或者设备能够看到最新的、正确的数据。处理不好的话，很容易引起数据不一致的问题。</p>
<p>一般的操作流程为：使用dma_map{single, sg}()进行DMA映射，然后每次DMA传输完成后，使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_single_for_cpu(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_sg_for_cpu(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>来进行一次同步，以便让CPU获取最新的数据。</p>
<p>然后，如果想让设备获得DMA区域，在将权限交给硬件之前，调用如下的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_single_for_device(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_sg_for_device(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>最后传输完成后，调用相应的unmap API进行DMA资源的释放。如果在整个传输过程中，我们压根不访问数据，就不需要调用dma_sync_*()相关的API。</p>
<p>下面是使用了dma_sync_*()接口的一份伪代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">my_card_setup_receive_buffer(struct my_card *cp, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> mapping;</span><br><span class="line">  mapping = dma_map_single(cp-&gt;dev, buffer, len, DMA_FROM_DEVICE);</span><br><span class="line">  <span class="keyword">if</span> (dma_mapping_error(cp-&gt;dev, mapping))&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">       * delay and try again later or</span></span><br><span class="line"><span class="comment">       * reset driver.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">goto</span> map_error_handling;</span><br><span class="line">  &#125;</span><br><span class="line">  cp-&gt;rx_buf = buffer;</span><br><span class="line">  cp-&gt;rx_len = len;</span><br><span class="line">  cp-&gt;rx_dma = mapping;</span><br><span class="line">  </span><br><span class="line">  give_rx_buf_to_card(cp); </span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">my_card_interrupt_handler(<span class="keyword">int</span> irq, <span class="keyword">void</span> *devid, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_card</span> *<span class="title">cp</span> = <span class="title">devid</span>;</span></span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">if</span> (read_card_status(cp) == RX_BUF_TRANSFERRED) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_card_header</span> *<span class="title">hp</span>;</span></span><br><span class="line">    <span class="comment">/* Examine the header to see if we wish</span></span><br><span class="line"><span class="comment">     * to accept the data. But synchronize</span></span><br><span class="line"><span class="comment">     * the DMA transfer with the CPU first</span></span><br><span class="line"><span class="comment">     * so that we see updated contents.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dma_sync_single_for_cpu(&amp;cp-&gt;dev,</span><br><span class="line">                            cp-&gt;rx_dma,</span><br><span class="line">                            cp-&gt;rx_len,</span><br><span class="line">                            DMA_FROM_DEVICE);</span><br><span class="line">    <span class="comment">/* Now it is safe to examine the buffer. */</span></span><br><span class="line">    hp = (struct my_card header *)cp-&gt;rx_buf;</span><br><span class="line">    <span class="keyword">if</span> (header_is_ok(hp)) &#123;</span><br><span class="line">      dma_unmap_single(&amp;cp-&gt;dev, cp-&gt;rx_dma, cp-&gt;rx_len, DMA_FROM_DEVICE);</span><br><span class="line">      pass_to_upper_layers(cp-&gt;buf);</span><br><span class="line">      make_and_setup_new_rx_buf(cp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CPU should not write to </span></span><br><span class="line"><span class="comment">         * DMA_FROM_DEVICE-mapped area,</span></span><br><span class="line"><span class="comment">         * so dma_sync_single_for_device() is</span></span><br><span class="line"><span class="comment">         * not needed here. It would be required</span></span><br><span class="line"><span class="comment">         * for DMA_BIDRECTIONAL mapping if</span></span><br><span class="line"><span class="comment">         * the memory was modified.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      give_rx_buf_to_card(cp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次提醒，驱动不应该再使用virt_to_bus()和bus_to_virt()接口了。linux主线后续将会移除这两类的接口</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>DMA资源是有限的，当发生错误时，一定要进行相应的异常处理：</p>
<ul>
<li>查看dma_alloc_coherent()是否返回了NULL或者dma_map_sg返回了0</li>
<li>使用dma_mapping_error()来检查dma_map_single()和dma_map_page()返回的dma_addr_t是否有效</li>
</ul>
<p>多次申请DMA，但是在中间某次申请失败的话，前面成功申请的都需要去释放。</p>
<p>在网卡设备中，发送时申请DMA地址失败后，在ndo_start_xmit的hook函数中，需要调用dev_kfree_skb()进行socket资源的释放并且返回NETDEV_TO_OK。</p>
<p>而对于SCSI设备，则需要返回SCSI_MLQUEUE_HOST_BUSY。在以后的某些时刻，SCSI子系统会再次向驱动下发命令。</p>
<h2 id="优化为了unmap而多出来的状态空间开销"><a href="#优化为了unmap而多出来的状态空间开销" class="headerlink" title="优化为了unmap而多出来的状态空间开销"></a>优化为了unmap而多出来的状态空间开销</h2><p>在许多平台上，dma_unmap_(single, page) 实际上什么都不执行，仅相当于一个nop指令。跟踪映射的地址和长度是十分消耗空间的。为了避免在驱动代码中多了很多if define的语句。可以使用如下的方式来减少空间。</p>
<ul>
<li>使用DEFINE_DMA_UNMAP_{ADDR, LEN}来进行结构体的定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ring_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> mapping;</span><br><span class="line">  __u32 len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ring_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sk_buffer</span> *<span class="title">skb</span>;</span></span><br><span class="line">  DEFINE_DMA_UNMAP_ADDR(mapping);</span><br><span class="line">  DEFINE_DMA_UNMAP_LEN(len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用函数来对mapping和len的字段进行赋值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_addr_set(ringqp, mapping, FOO);</span><br><span class="line">dma_unmap_len_set(ringqp, len, BAR);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用dma_unmap_{addr, len}()进行资源释放：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_single(dev,</span><br><span class="line">                dma_unmap_addr(ringp, mapping),</span><br><span class="line">                dma_unmap_len(ringp, len),</span><br><span class="line">                DMA_FROM_DEVICE);</span><br></pre></td></tr></table></figure>

<h2 id="平台相关的一些主题"><a href="#平台相关的一些主题" class="headerlink" title="平台相关的一些主题"></a>平台相关的一些主题</h2><ul>
<li>如果平台支持IOMMU（包括软件的IOMMU），则内核编译时，需要是能CONFIG_NEED_SG_DMA_LENGTH</li>
<li>ARCH_DMA_MINALIGN</li>
</ul>
<p>架构必须保证kmalloc申请的buffer是DMA安全的。驱动和子系统都依赖于这一点。如果某个平台不是完全DMA一致（比如硬件不能保证在CPU cache中的数据和主存中的数据一致），ARCH_DMA_MINALIGN必须被设置上，以便时内存分配器能够保证kmalloc分配的buffer没有共享cacheline。可以查看一个例子：arch/arm/include/asm/cache.h</p>
<p>需要注意的是，ARCH_DMA_MINALIGN是关于DMA内存对齐的约束。我们不需要关心普通数据的对齐一致性问题。</p>
<p>（Done）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/03/21/0022-wireshark-bugs-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/21/0022-wireshark-bugs-list/" class="post-title-link" itemprop="url">Wireshark的一些bug记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-21 22:30:03" itemprop="dateCreated datePublished" datetime="2017-03-21T22:30:03+08:00">2017-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-07-24 12:15:14" itemprop="dateModified" datetime="2017-07-24T12:15:14+08:00">2017-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">经验分享</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近我在定位一些问题的时候，用到wireshark来查看抓到的报文，里面出现了一些奇奇怪怪的错误解析。不由得感慨，即使是像wireshark这样的开源工具，也有相当一部分代码写得很挫。下面列举了一些我看到的wireshark的bug，曾经的或者现在还存在的。就不区分了。</p>
<h1 id="解析TCP报文时，NextSeq计算出错。"><a href="#解析TCP报文时，NextSeq计算出错。" class="headerlink" title="解析TCP报文时，NextSeq计算出错。"></a>解析TCP报文时，NextSeq计算出错。</h1><p>TCP协议中，SYN报文和FIN报文都会占用1字节的序列号。wireshark在显示带数据的tcp报文时，会计算出Next sequence number的值。但是这个值在数据带FIN的情况下计算错误，没有包含FIN带的那个序列号。比如说起始sequence为100，数据100Byte，带了一个FIN标志，那么Next sequence number的值应该为100 + 100 + 1，而非100 + 100（虽然FIN后面不会有数据了，但是这个计算方式还是有问题的）。</p>
<p>接下来，我们在wireshark的源代码中找到它是如何计算。首先，全局搜索显示在wireshark中的“Next sequence number”，我们找到了下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">proto_register_tcp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> hf_register_info hf[] = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略部分代码 */</span></span><br><span class="line">        &#123; &amp;hf_tcp_nxtseq,</span><br><span class="line">        &#123; <span class="string">"Next sequence number"</span>,   <span class="string">"tcp.nxtseq"</span>, FT_UINT32, BASE_DEC, <span class="literal">NULL</span>, <span class="number">0x0</span>,</span><br><span class="line">            <span class="literal">NULL</span>, HFILL &#125;&#125;,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">/* 省略部分代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了Next sequence number关联到了hf_tcp_nxtseq，可以认为hf_tcp_nxtseq是一个句柄，索引了一个条目，标识了这个字段的一些相关属性。我们接下来搜索hf_tcp_nxtseq变量，可以看到在两个位置用到了，这两个位置是挨着的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数dissect_tcp中 */</span></span><br><span class="line">    <span class="keyword">if</span> (tcph-&gt;th_have_seglen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nxtseq != tcph-&gt;th_seq) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tcp_relative_seq) &#123;</span><br><span class="line">                tf=proto_tree_add_uint_format_value(tcp_tree, hf_tcp_nxtseq, tvb, offset, <span class="number">0</span>, nxtseq, <span class="string">"%u    (relative sequence number)"</span>, nxtseq);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tf=proto_tree_add_uint(tcp_tree, hf_tcp_nxtseq, tvb, offset, <span class="number">0</span>, nxtseq);</span><br><span class="line">            &#125;</span><br><span class="line">            PROTO_ITEM_SET_GENERATED(tf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，显示的值来源于变量nxtseq，我们向上看看这个函数，看看在哪里有对这个值进行赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nxtseq = tcph-&gt;th_seq + tcph-&gt;th_seglen;</span><br><span class="line"><span class="keyword">if</span> ((tcph-&gt;th_flags&amp;(TH_SYN|TH_FIN)) &amp;&amp; (tcph-&gt;th_seglen &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    nxtseq += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咦，怎么跟我在公司看到的不一样？好吧，可能是新版本已经修复了。当报文中的头打上了TH_SYN或者TH_FIN的时候，序列号会增加1。这样就对了嘛。在公司上还停留在较早一点的版本上，是没有那个if分支的，我的修改方法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nxtseq = tcph-&gt;th_seq + tcph-&gt;th_seglen + ((tcph-&gt;th_flags &amp; (TH_SYN | TH_FIN)) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h1 id="TCP错误判断SPURIOUS重传"><a href="#TCP错误判断SPURIOUS重传" class="headerlink" title="TCP错误判断SPURIOUS重传"></a>TCP错误判断SPURIOUS重传</h1><p>在wireshark解析tcp报文中，有一种类型的重传会被打上Spurious retransmission。如果我们重传的数据（或者FIN、SYN）已经被对方的ack确认了，但是还是发生了这个数据的重传，这个时候就会被wireshark解析判断为spurious重传。</p>
<p>但是有一个特殊的场景wireshark会错误地判断，这个特殊的场景还是FIN或者SYN的时候。以FIN为例，我们发送FIN的序列号为100，对端最后ack我们的序列号为100；当对端不给我们这个FIN的ack时（ack seq = 101），我们会多次重传FIN，这些FIN的重传其实是正常的，但是wireshark还是会把他们解析为spurious。为什么呢？我们用上面相似的策略来搜索源代码，可以找到下面这段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( seq + seglen &lt;= tcpd-&gt;rev-&gt;tcp_analyze_seq_info-&gt;lastack ) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!tcpd-&gt;ta)&#123;</span><br><span class="line">        tcp_analyze_get_acked_struct(pinfo-&gt;num, seq, ack, TRUE, tcpd);</span><br><span class="line">    &#125;</span><br><span class="line">    tcpd-&gt;ta-&gt;flags|=TCP_A_SPURIOUS_RETRANSMISSION;</span><br><span class="line">    <span class="keyword">goto</span> finished_checking_retransmission_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没？对于上面的那个例子来讲，seq = 100，seglen = 0， lastack = 100，这个条件就是满足的，那么就会被认为是spurious重传。这里的判断条件也应该修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( seq + seglen + ((tcph-&gt;th_flags &amp; (TH_SYN | TH_FIN)) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) &lt;= tcpd-&gt;rev-&gt;tcp_analyze_seq_info-&gt;lastack )</span><br></pre></td></tr></table></figure>

<h1 id="在tcp序列号翻转的情况下，计算iwarp报文的payload长度错误"><a href="#在tcp序列号翻转的情况下，计算iwarp报文的payload长度错误" class="headerlink" title="在tcp序列号翻转的情况下，计算iwarp报文的payload长度错误"></a>在tcp序列号翻转的情况下，计算iwarp报文的payload长度错误</h1><p>这个错误实际上不应该，我们有一个场景是测试序列号翻转情况下我们的机器能否正常工作，抓包上看到处于序列号翻转位置的报文被打上了错误的标志，同时前后的报文都没有问题，那么肯定是序列号翻转时候的一些计算有问题，经过分析，怀疑长度有问题。依然翻看wireshark的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> guint32</span><br><span class="line">fpdu_total_length(struct tcpinfo *tcpinfo)</span><br><span class="line">&#123;</span><br><span class="line">	guint32 size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcpinfo-&gt;seq &lt; tcpinfo-&gt;nxtseq) &#123;</span><br><span class="line">		size = tcpinfo-&gt;nxtseq - tcpinfo-&gt;seq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcpinfo-&gt;seq &gt;= tcpinfo-&gt;nxtseq) &#123;</span><br><span class="line">		size = tcpinfo-&gt;nxtseq + (TCP_MAX_SEQ - tcpinfo-&gt;seq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数是计算fpdu的整个长度。当起始序列号小于这个报文结束后一字节的序列号时，size = tcpinfo-&gt;nxtseq - tcpinfo-&gt;seq。否则size = tcpinfo-&gt;nxtseq + (TCP_MAX_SEQ - tcpinfo-&gt;seq)。TCP_MAX_SEQ为0xffffffff。<br>前一种情况计算起来是没有问题的，后面一个公式是什么鬼？如果seq = 0xffffffff，报文长1字节，那么nxtseq = 0x0，根据公式计算，size = 0？简直逗比的公式啊。<br>正确的写法不解释了，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> guint32</span><br><span class="line">fpdu_total_length(struct tcpinfo *tcpinfo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tcpinfo-&gt;nxtseq - tcpinfo-&gt;seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2016/07/13/0021-wireshark-bugs-of-iWarp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/13/0021-wireshark-bugs-of-iWarp/" class="post-title-link" itemprop="url">Wireshark中关于iWarp报文解析的两处bug</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-13 23:37:04" itemprop="dateCreated datePublished" datetime="2016-07-13T23:37:04+08:00">2016-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2016-07-31 23:01:20" itemprop="dateModified" datetime="2016-07-31T23:01:20+08:00">2016-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">经验分享</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近工作很忙，连周三默认不加班日，也需要到9点左右才能回来。搞的这么晚，也是因为测试同事的一个问题单。经过一番折腾，在茫茫几十上百万行的日志中，终于找到了蛛丝马迹，肯定了自己猜测，测试同事的自动脚本不靠谱啊，脚本提示关键词没有出现在log中，自己也就相信了，结果凑巧发现其他问题时，发现居然有………终于可以安心回家了。</p>
<p>今天其实想写的，是另外一个事情。最近的工作跟网络的RDMA协议相关，具体是iWarp协议。iWarp协议这个东西呢，细节可以参考相关的RFC。跟网络协议打交道，离不开的重要工具就是Wireshark了，用它来分析报文是常有的事。但这个工具对iWarp的支持不是特别的好，同时也会存在一些bug，经常会分析出一些错误的信息误导我们。比如说下面两条：</p>
<p>（1）iWarp协议中有一个Marker类似的东西，它的作用是用来给报文定界的。iWarp协议中，报文传输以FPDU为单位。TCP协议在网络当中会产生乱序的现象，一般的上层协议处理需要等TCP层完成乱序处理后，才能进行处理相应的协议处理。但iWarp开启了Marker功能之后，就不一般了。Marker实际上是报文当中的4个字节，每隔512Byte都有一个Marker，这个Marker的值等于从该位置到报文头的距离（落在报文间的Marker值为0）。一条流的第一个Marker是这条流进入FPDU模式后的前4字节。</p>
<p>举一个例子，一个新的iWarp连接（基于TCP），进入FPDU模式后的tcp序列号为100，那么100～103字节就是这条流的第一个Marker，它的值为0。如果接下来第一个iWarp报文为1440B，这个报文的序列号就是从100～1539B，100～103、612～615、1124～1127就是这个报文当中的所有Marker。</p>
<p>Wireshark在解析报文时候，会计算出这个报文中的Marker数目。在大多数情况下，Wireshark的计算都是没有问题的，但不凑巧。如果一个报文为512的整数倍，同时报文起始就时一个Marker的时候，这个计算就问题大大的了。</p>
<p>（2）第二个问题还是关于Marker的。Marker是否开启是通信双方协商的，通过MPA协商告诉对方本端是否支持Marker，如果A通告Marker使能，说明A有能力接收Marker，这样B发送的报文中就会携带Marker；同理B也一样。使不使能Marker是会影响报文解析的。Wireshark有一个毛病：如果双方一方使能了Marker，而另外一方没有使能Marker，它就认为双方都使能了Marker，然后进行报文解析。这样的话，没有使能Marker的那一方的报文就全被解析错误了。</p>
<p>开发iWarp协议相关的项目时，这两个bug还是对开发调试有所影响的，改起来也比较方便。其实在公司里面已经都把代码给改了，重新发布给同事了来用，只是信息安全的问题，不可能把代码拿出来。有空的时候，自己在家再开发一下，最好是把bug反馈给wireshark的maintainer，也算贡献一把社区。：）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chenny Chen</p>
  <div class="site-description" itemprop="description">码农的午后抒怀</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Seitran" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Seitran" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenny Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
