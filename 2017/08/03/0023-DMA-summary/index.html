<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"seitran.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="从大学本科开始就接触了DMA的概念，但没有系统的总结过。结合工作的经验，以及内核相关文档，便有了这份总结。 教课书中的概念就不再赘述了。DMA实际上是赋予了设备在CPU的控制下，对memory进行读写访问的的能力。所谓的“CPU的控制”，指的是控制路径，CPU&#x2F;软件当然要对DMA的地址、长度进行设置，对不同的设备的DMA空间进行隔离等；而实际的DMA动作，则是by pass CPU的。 谈到DMA">
<meta property="og:type" content="article">
<meta property="og:title" content="DMA学习总结">
<meta property="og:url" content="http://seitran.com/2017/08/03/0023-DMA-summary/index.html">
<meta property="og:site_name" content="Chenny的Blog">
<meta property="og:description" content="从大学本科开始就接触了DMA的概念，但没有系统的总结过。结合工作的经验，以及内核相关文档，便有了这份总结。 教课书中的概念就不再赘述了。DMA实际上是赋予了设备在CPU的控制下，对memory进行读写访问的的能力。所谓的“CPU的控制”，指的是控制路径，CPU&#x2F;软件当然要对DMA的地址、长度进行设置，对不同的设备的DMA空间进行隔离等；而实际的DMA动作，则是by pass CPU的。 谈到DMA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://seitran.com/images/17_1.png">
<meta property="article:published_time" content="2017-08-03T15:08:40.000Z">
<meta property="article:modified_time" content="2017-11-15T14:16:20.000Z">
<meta property="article:author" content="Chenny Chen">
<meta property="article:tag" content="DMA">
<meta property="article:tag" content="学习总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://seitran.com/images/17_1.png">

<link rel="canonical" href="http://seitran.com/2017/08/03/0023-DMA-summary/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>DMA学习总结 | Chenny的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chenny的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">All the SECRETS are behind the SOURCE CODE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://seitran.com/2017/08/03/0023-DMA-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenny Chen">
      <meta itemprop="description" content="码农的午后抒怀">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenny的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DMA学习总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-03 23:08:40" itemprop="dateCreated datePublished" datetime="2017-08-03T23:08:40+08:00">2017-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-11-15 22:16:20" itemprop="dateModified" datetime="2017-11-15T22:16:20+08:00">2017-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Linux内核</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>从大学本科开始就接触了DMA的概念，但没有系统的总结过。结合工作的经验，以及内核相关文档，便有了这份总结。</p>
<p>教课书中的概念就不再赘述了。DMA实际上是赋予了设备在CPU的控制下，对memory进行读写访问的的能力。所谓的“CPU的控制”，指的是控制路径，CPU/软件当然要对DMA的地址、长度进行设置，对不同的设备的DMA空间进行隔离等；而实际的DMA动作，则是by pass CPU的。</p>
<p>谈到DMA，不可避免的会涉及到不同的地址转换，这对理解Linux下面的DMA是十分重要的。总共有三类地址：虚拟地址，物理地址以及总线地址。</p>
<p>内核通常使用<strong>虚拟地址</strong>，比如像<em>kmallc()</em>，<em>vmalloc()</em>和类似的接口返回的地址都是void *类型的虚拟地址。</p>
<p>虚拟内存系统，比如TLB，页表等，会将虚拟地址转换成CPU的物理地址。物理地址的类型一般为phy_addr_t或者resource_size_t。外设的寄存器，内核实际上是把它们当成物理地址来进行管理，这些地址可以在/proc/iomem中被访问。这些物理地址不能直接被驱动程序使用，必须使用ioremap()来将这些地址映射为虚拟地址之后，才能被驱动所使用。这也就是为什么我们的驱动程序中，总是会看到设备的寄存器地址空间被ioremap后，才能被正确访问。</p>
<p>对于IO设备来讲，它们使用的地址通常被称为总线地址（bus address）。如果设备的寄存器在MMIO地址空间，或者它使用DMA对memory进行读写访问，这个过程中设备所使用的地址其实就是总线地址。在一些硬件架构中，总线地址和CPU的物理地址是相同的，但是并不是所有的都这样。IOMMU和host bridge可以在总线地址和物理地址之间进行任意的映射。</p>
<p>从设备的角度来讲，DMA使用总线地址空间或者总线地址空间的一个子集。比如说，虽然系统支持64-bit的地址空间，但是经过IOMMU，设备可能仅仅使用32-bit的地址空间就可以了。</p>
<img src="/images/17_1.png" class="" width="400" height="600" title="一个地址转换的示例">

<p>在枚举过程中，内核会获取到IO设备、它们的MMIO空间以及所挂载的桥设备。例如，一个PCI设备有BAR空间，内核从BAR空间中拿到总线地址（A)，并且将它转换成CPU物理地址（B）。地址（B）被存储在struct resource结构中，并且通过/proc/iomem暴露出来。当驱动probe设备的时候，通常会用ioremap()来讲物理地址（B）映射成虚拟地址（C)。此时，就可以通过类似ioread32（C)来访问到设备在总线地址（A)上的寄存器。</p>
<p>驱动程序同样的，可以使用kmalloc()和类似的接口，来分配一个buffer。接口返回的地址实际上是虚拟地址，如虚拟地址（X)。虚拟内存系统将X映射到物理地址（Y)。驱动可以使用虚拟地址（X)来访问这个buffer，但是设备不能使用这个地址，因为DMA不会经过CPU的虚拟内存系统。</p>
<p>在一些简单的系统中，设备可以直接向屋里地址Y进行DMA访问。但是在其他的系统中，一般需要一种硬件，比如IOMMU，建立DMA地址（总线地址）和物理地址的映射关系。比如，将地址（Z）转换成地址（Y)。dma_map_single()接口其实就是做了这么一个事情：传入了虚拟地址X，然后设置IOMMU映射，然后返回了总线地址（DMA地址）Z。映射之后，驱动就可以告诉设备使用地址（Z)进行DMA，IOMMU会将对这个地址的DMA操作映射到实际的RAM中的地址Y上。</p>
<p>Linux系统也能支持动态DMA映射，驱动只需要在地址实际使用之前进行mapping，在使用之后进行unmap即可。</p>
<h2 id="DMA相关的API"><a href="#DMA相关的API" class="headerlink" title="DMA相关的API"></a>DMA相关的API</h2><p>DMA相关的API与底层的架构无关，因为Linux已经替我们做好了HAL层。所以我们使用DMA API的使用，不应该使用总线相关的API，比如使用dma_map_<em>()，而非pci_map_</em>()接口。</p>
<p>在我们的驱动程序里，应该包含头文件linux/dma-mapping.h，这个头文件提供了dma_addr_t的定义。dma_addr_t可以提供对任何平台的dma地址的支持。</p>
<h2 id="内存的DMA可用性"><a href="#内存的DMA可用性" class="headerlink" title="内存的DMA可用性"></a>内存的DMA可用性</h2><p>哪些内存可以被用作DMA？有一些不成文的规则。</p>
<p>使用页面分配函数（比如__get_gree_page*())或者通用内存分配函数（比如kmalloc()、kmem_cache_alloc()）分配的地址一般是可以来用作DMA地址的。</p>
<p>而使用vmallc()函数分配的地址最好不要用作DMA，因为vmalloc分配出来的地址在物理地址上不一定连续，进行DMA的时候可能需要遍历页表去拿到物理地址，而将这些物理地址转成虚拟地址的时候，又需要使用到__va（）类似的函数。</p>
<p>所以，我们一般不能使用内核镜像地址（比如data/text/bss段），或者模块镜像地址、栈地址来进行DMA，这些地址可能被映射到物理内存上的任意位置。即使我们要使用这些种类的地址来进行DMA，我们也需要确保I/O buffer是cacheline对齐的。否则，就很容易在DMA-incoherent cache上出现cache一致性的问题。</p>
<p>我们也不能使用kmap()返回的地址来进行DMA，原因与vmalloc()类似。</p>
<p>块I/O和网络设备的buffer怎么分配的呢？实际上，块I/O和网络子系统会保证它们使用的地址是可以进行DMA的。</p>
<h2 id="DMA地址的限制"><a href="#DMA地址的限制" class="headerlink" title="DMA地址的限制"></a>DMA地址的限制</h2><p>设备对于DMA地址空间一般都有一定的限制，比如说我们的设备的寻址能力只有24bit，那么我们一定要将限制通知到内核。</p>
<p>默认情况下，内核认为设备的寻址空间可以达到32bit。对于有64bit寻址能力的设备来讲，我们需要告知内核调大这个能力。而对于不足32bit寻址能力的设备来讲，需要告诉内核降低这个能力。</p>
<p>需要特别注意的一点是：PCI-X规范要求PCI-X设备要能够支持64-bit的寻址（DAC）的数据传输。并且某些平台（SGI SN2）也要求当IO总线是PCI-X模式时，必须要支持64bit的consistent分配。</p>
<p>正确的操作应该是：我们必须在设备的probe函数中向内核查询机器的DMA控制器能否正常支持当前设备的DMA寻址限制。即使设备支持默认的设置，我们最好也在probe函数中这么做。起码说明我们考虑到了这个事情。</p>
<p>通过调用dma_set_mask_and_coherent()可以完成这种能力通知：函数原型为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask_and_coherent</span><span class="params">(struct device *dev, u64 mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数可以同时通知streaming和coherent DMA的寻址能力。如果有特殊的需求的话，也可以使用下面两个单独的查询函数：</p>
<p>设置streaming DMA的能力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask</span><span class="params">(struct device *dev, u64 mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设置consistent DMA的能力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_coherent_mask</span><span class="params">(struct device *dev, u64 mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这些函数中，dev指向设备所对应的struct device结构体，mask是一个bit域的mask值，用来描述设备支持哪些bit位宽的寻址能力。如果这个函数返回了0，则表示设备能够在当前的机器上正常的DMA。通常情况下，设备的struct device结构体会嵌入在设备的总线相关的struct device结构体中。比如，&amp;pdev-&gt;dev是一个指向我们的设备，我们的设备是挂载到PCI上，而pdev则是指向了我们设备的PCI struct device结构体。</p>
<p>如果返回值不是0，那么表明我们设备在这个平台上不能正常的完成DMA操作，如果强行做的话，会导致不可预期的结果。要么我们使用不同的mask掩码，要么不要使用DMA。</p>
<p>这意味着当上面三个函数返回失败后，我们可以做如下几个事情：</p>
<ol>
<li>如果可能的话，使用其他的mask掩码</li>
<li>如果可能的话，在数据传输时，使用非DMA方式</li>
<li>忽略这个设备，并且不初始化它（不使用这个设备了）</li>
</ol>
<p>当出现第2点和第3点的时候，建议使用KERN_WARNING级别的打印来输出一条消息。这样以来，当用户使用我们的设备时发现有问题或者设备不能被检测到时，可以通过内核打印来找到原因。</p>
<p>对于标准的32bit寻址能力的设备，可以使用如下的代码进行设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="number">32</span>))) &#123;</span><br><span class="line">  	dev_warn(dev, <span class="string">"mydev: No suitable DMA available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于具有64bit寻址能力的设备来讲，我们一般首先会尝试设置64bit的寻址能力，但是如果返回失败的话，则会尝试32bit的寻址能力。通常情况下，之所以会设置64bit寻址能力失败，可能仅仅是因为32bit的寻址能力相对于64bit的寻址能力更加高效。比如，在Sparc64中，PCI SAC寻址比DAC寻址更快。</p>
<p>以具有64bit寻址能力的设备设置streaming DMA能力为例，可以使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> using_dac;</span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="number">64</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="number">32</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dev_warn(dev, <span class="string">"mydev: No suitable DMA available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果也要设置consistent DMA能力的话，则使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> using_dac, consistent_using_dac;</span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MSAK(<span class="number">64</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">1</span>;</span><br><span class="line">  	consistent_using_dac = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(<span class="number">32</span>))) &#123;</span><br><span class="line">    using_dac = <span class="number">0</span>;</span><br><span class="line">  	consistent_using_dac = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dev_warn(dev, <span class="string">"mydev: No suitable DMA available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>coherent  DMA的掩码与streaming DMA的mask相等或者要小一些。极少数的设备只支持consistent分配，那么我们就必须使用检查dma_set_coherent_mask()的返回值。</p>
<p>最后，如果设备支持24bit的寻址空间的话，我们需要这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, DMA_BIT_MASK(<span class="number">24</span>))) &#123;</span><br><span class="line">    dev_warn(dev, <span class="string">"mydev: 24-bit DMA addressing not available.\n"</span>);</span><br><span class="line">  	<span class="keyword">goto</span> ignore_this_device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当dma_set_mask()或者dma_set_mask_and_coherent()成功（返回值为0）的话，内核会将我们提供的mask信息保存下来，并在后续做DMA mapping的时候使用。</p>
<p>还有一种比较特殊的场景需要考虑，比如说设备支持多个功能（如一个声卡支持播放和录音功能），不同的功能有不同的DMA寻址限制。这时我们希望在probe的时候能够针对不同功能设置合适的mask掩码。但实际上，只有最后一次调用的dma_set_mask()才生效。下面是一份伪代码来描述这种场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYBACK_ADDDRESS_BITS	DMA_BIT_MASK(32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_ADDRESS_BITS		DMA_BIT_MASK(24)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, PLAYBACK_ADDRESS_BITS)) &#123;</span><br><span class="line">    card-&gt;playback_enabled = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    card-&gt;playback_enabled = <span class="number">0</span>;</span><br><span class="line">  	dev_warn(dev, <span class="string">"%s: Playback disabled due to DMA limiatations.\n"</span>, card-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dma_set_mask(dev, RECORD_ADDRESS_BITS)) &#123;</span><br><span class="line">  	card-&gt;record_enabled = <span class="number">1</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    card-&gt;record_enabled = <span class="number">0</span>;</span><br><span class="line">  	dev_warn(dev, <span class="string">"%s: Record disabled due to DMA limiations.\n"</span>, card-&gt;name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子使用的声卡设备如果是PCI设备的话，其实就像是ISA标准残留下来的“垃圾”，因为这种设备还保持着ISA标准所具有的16M的DMA寻址空间限制。</p>
<h2 id="两种类型的DMA映射"><a href="#两种类型的DMA映射" class="headerlink" title="两种类型的DMA映射"></a>两种类型的DMA映射</h2><p>一般有两种类型的DMA映射：</p>
<h3 id="一致性DMA映射（consistent-DMA）"><a href="#一致性DMA映射（consistent-DMA）" class="headerlink" title="一致性DMA映射（consistent DMA）"></a>一致性DMA映射（consistent DMA）</h3><p>这种类型的DMA通常是在驱动初始化的时候进行映射。在驱动卸载时候进行unmap。硬件应该保证设备和CPU可以并发的访问DMA数据。不需要显示的进行数据flush，任何一方都可以看到另外一方写入的最新数据。consistent DMA也可以理解成synchronous或者coherent。当前默认会将consistent DMA申请的内存放在低32bit寻址的空间内，但是为了以后的兼容性，即使当前的默认值对于我们的设备也ok，我们写驱动程序的时候，还是应该显示地进行一致性DMA mask的设置。</p>
<p>经常使用consistent映射的一些场景包括：</p>
<ul>
<li>网卡设备的DMA ring环描述符</li>
<li>SCSI适配器的mailbox的命令数据结构</li>
<li>设备主存放不下的设备固件微码</li>
</ul>
<p>上面描述的这三种应用场景都要求CPU对于DMA内存的修改都可以立刻被设备看到，设备对于DMA内存的修改也可以被CPU立刻看到。consisitent DMA映射可以保证这一点。</p>
<p><strong>特别需要注意的一点是</strong>，一致性DMA不能提供相关的内存屏障。现代CPU一般都可能将指令打乱以提高指令执行的性能，而这些被打乱的指令里面一旦有访问一致性DMA的store/load等指令时，情况就会变得很微妙。比如说有一个描述符，word0中的内容必须先被更新，word1的内容一定要后被更新。那么我们必须写类似于下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc-&gt;word0 = address;</span><br><span class="line">wmb();</span><br><span class="line">desc-&gt;word1 = DESC_VALID;</span><br></pre></td></tr></table></figure>

<p>内存屏障之前的指令一定会先于内存屏障之后的指令执行。因此上面的这段代码保证了在使能desc之前，就将地址放入word0中。值得一提的是，wmb是一个与平台无关的内存屏障，这样就保证了代码在任何平台上都能得到正确的结果。</p>
<p>在一些平台上，我们可能需要刷新CPU的写buffer或者PCI桥的写buffer。通常的做法是在写操作之后加一个读操作。</p>
<h3 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h3><p>流式DMA映射一般用在一次DMA传送过程中，使用完即可unmap（除非使用了dma_sync_*）。硬件可以对这种DMA映射的访问进行顺序访问的优化。</p>
<p>可以将“streaming”理解成“异步的”（asynchronous）或者“非一致性的”（outside the coherency domain）。</p>
<p>经常使用流式DMA的一些场景包括</p>
<ul>
<li>网络设备的发送/接收buffer；</li>
<li>SCSI设备的文件系统的读写buffer。</li>
</ul>
<p>流式DMA映射的接口设计，允许具体的实现可以进行任何硬件设备所允许的优化。最后，使用这类映射时，我们需要对自己想要什么样的结果十分清楚。</p>
<p>任何一种类型的DMA映射都不会因为底层的总线类型而产生一些字节对齐的限制，也许某些设备本身会有类似的限制。</p>
<p>同时，在具有cache功能的平台上，当DMA buffer没有和其他数据产生冲突（在同一个cache line）时，这个时候的DMA性能是最高的。</p>
<h2 id="使用一致性DMA映射"><a href="#使用一致性DMA映射" class="headerlink" title="使用一致性DMA映射"></a>使用一致性DMA映射</h2><p>如果想要分配和映射大（PAGE_SIZE或者更大的）的一致性DMA区域，我们应该使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dma_addr_t</span> dma_handle;</span><br><span class="line">cpu_addr = dma_alloc_coherent(dev, size, &amp;dma_handle, gfp);</span><br></pre></td></tr></table></figure>

<p>dev是一个struct device *类型的变量，这个函数可以在中断上下文中被调用，只要使用了GFP_ATOMIC标志。size是我们要分配的区域大小，单位是Byte。</p>
<p>该函数会在RAM中分配相应的空间，它表现和__get_free_pages()的行为很相似（参数有些区别，比如size表示字节数，而get_free_pages则是指数次幂）。如果设备想分配的区域小于1个page，使用dma_poll相关的接口会更好一些。</p>
<p>一致性DMA映射的接口，当dev非空时，默认情况下会返回一个32bit寻址范围内的DMA地址。当设备显式地调用dma_set_coherent_mask来设置DMA掩码的时候，这个接口对一致性DMA映射的函数分配才会返回大于32bit寻址范围外的地址。dma_pool的接口也是类似的。</p>
<p>dma_alloc_coherent()会返回两个值：通过CPU可以访问的虚拟地址以及可以传递给硬件的dma_handler。这两个地址还有一个特点：他们都被对齐到PAGE_SIZE的2的指数次幂。</p>
<p>可以使用如下接口进行unmap操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_free_coherent(dev, size, cpu_addr, dma_handle);</span><br></pre></td></tr></table></figure>

<p>接口中dev、size和之前的入参一致，而cpu_addr、dma_handle是alloc函数的返回值。这个函数也可以在中断上下文中被调用。</p>
<p>如果我们需要少量的内存的话，我们可以自己写代码来利用dma_alloc_coherent()返回的地址作为内存池，也可以使用dma_pool接口来做这样的事情。dma_poll类似于kmem_cache，不同的是dma_pool利用的是dma_alloc_coherentl来进行内存分配，而kmem_cache利用的是__get_free_page进行内存分配。此外，dma_pool也会考虑到一些硬件对齐上的限制。</p>
<p>可以使用如下接口来创建一个dma_pool：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">poll = dma_pool_create(name, dev, size, align, boundary);</span><br></pre></td></tr></table></figure>

<p>参数name就是一个名字咯，dev和size与上面都一样。设备的对齐的硬件限制就可以通过align来告诉内核。align必须是2的整数次幂，以byte为单位。如果设备没有对齐的限制，则可以传入0；如果传入4096，则是告诉内核，该pool中的地址不能跨越4K Byte边界，但是在这种场景直接使用dma_alloc_coherent会更好一些。</p>
<p>申请好pool之后，可以使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu_addr = dma_pool_alloc(pool, flags, &amp; dma_handle);</span><br></pre></td></tr></table></figure>

<p>来完成DMA内存申请。flags可以使用GFP_KERNEL（如果允许阻塞）、GFP_ATOMIC等。类似于dma_alloc_coherent()，本函数返回2个值：cpu_addr和dma_handle。</p>
<p>如果要释放从dma_pool中申请的内存，可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_pool_free(pool, cpu_addr, dma_handle);</span><br></pre></td></tr></table></figure>

<p>pool同dma_pool_alloc中传入的pool一致，cpu_addr和dma_handle是dma_pool_alloc返回的对应值。这个函数可以在中断上下文中被调用。</p>
<p>如果要注销dma_pool，可以使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_pool_destroy(pool);</span><br></pre></td></tr></table></figure>

<p>需要在调用这个函数之前，保证从pool中申请的内存都已经被释放完成。这个函数不能在中断上下文中被调用。</p>
<h2 id="DMA方向"><a href="#DMA方向" class="headerlink" title="DMA方向"></a>DMA方向</h2><p>部分的DMA接口函数中，有参数来描述DMA的方向（这个参数在后面会看到），参数是一个整数，并且只能够取如下几个值：</p>
<ul>
<li>DMA_BIDIRECTIONAL</li>
<li>DMA_TO_DEVICE</li>
<li>DMA_FROM_DEVICE</li>
<li>DMA_NONE</li>
</ul>
<p>如果调用函数的时候知道DMA的方向，那么就需要向函数调用提供准确的值。</p>
<p>DMA_TO_DEVICE表示数据传输从主存到设备，而DMA_FROM_DEVICE表示数据传输从设备到主存。</p>
<p>我们需要准确地提供这个值。如果我们实在不知道或者无法确定，那么可以使用DMA_BIDIRECTIONAL。这个参数表示DMA传输可以是任何一个方向。平台可以保证我们这样做且能够正常工作，但是是以性能为代价的。</p>
<p>DMA_NONE是用来调试的。在知道准确方向之前，我们可以将对应的结构体中的值保存为DMA_NONE。一旦因此程序fail的话，可以捕捉到这部分的异常逻辑并进行修复。</p>
<p>这个值还有一个作用是可以用来debug（这个与上一段中的debug不同）。某些硬件平台上，，可以对DMA映射的地址是否可写进行标注，类似于用户地址空间中的页保护。因此，恰当的标注和DMA方向不匹配时，硬件可以捕获这个错误然后上报，进行更深度的DMA保护。</p>
<p>streaming映射需要指定一个方向，而一致性DMA映射不需要指定方向，一致性DMA映射隐含着DMA_BIDIRECTIONAL属性。</p>
<p>在SCSI子系统中，使用SCSI命令中的sc_data_direction来表示DMA的实际方向。</p>
<p>对于网络设备驱动来讲，就更简单了。发送报文时，使用DMA_TO_DEVICE方向来进行map/unmap。而接收报文时，使用DMA_FROM_DEVICE来进行map/unmap。</p>
<h2 id="使用流式DMA映射"><a href="#使用流式DMA映射" class="headerlink" title="使用流式DMA映射"></a>使用流式DMA映射</h2><p>流式DMA映射函数可以在中断上下文中被调用，它有大类map/unmap函数族，一类是映射单个DMA区域，另外一个则是映射DMA地址链。</p>
<p>下面是一个映射单个DMA region的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">my_dev</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">dma_addr_t</span> dma_handle;</span><br><span class="line"><span class="keyword">void</span> *addr = buffer-&gt;ptr;</span><br><span class="line"><span class="keyword">size_t</span> size = buffer-&gt;len;</span><br><span class="line"></span><br><span class="line">dma_handle = dma_map_single(dev, addr, size, direction);</span><br><span class="line"><span class="keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">   * delay and try again later or</span></span><br><span class="line"><span class="comment">   * reset driver.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">goto</span> map_error_handling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是unmap的示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_single(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>调用dma_map_single()后，需要使用dma_mapping_error()来进行检测。这样做是为了保证映射的代码不依赖于某个平台的具体DMA实现。不检测的话，会带来预期意外的问题。dma_map_page()也是一样的。</p>
<p>DMA完成后，要使用dma_unmap_single()来释放，比如在通知host DMA已经完成的中断中来调用这个函数去释放相应的DMA区域。</p>
<p>使用这类的DMA映射具有一个缺点：我们不能引用到HIGHMEM的内存。为了访问HIGHMEM的内存，可以使用另外一组直接操作page/offset的DMA map/unmap函数。下面是使用这组函数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">my_dev</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">dma_addr_t</span> dma_handle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">buffer</span>-&gt;<span class="title">page</span>;</span> </span><br><span class="line"><span class="keyword">size_t</span> size = buffer-&gt;len;</span><br><span class="line"></span><br><span class="line">dma_handle = dma_map_page(dev, page, offset, size, direction);</span><br><span class="line"><span class="keyword">if</span> (dma_mapping_error(dev, dma_handle)) &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">     * delay and try again later or </span></span><br><span class="line"><span class="comment">     * reset driver.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="keyword">goto</span> map_error_handling;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">dma_unmap_page(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>这里面，offset指的是页内的偏移。同样的，要使用dma_mapping_error来检查是否映射出错。使用完DMA映射后，调用dma_unmap_page来进行资源释放。</p>
<p>如果使用scatterlists，可以使用如下代码来进行DMA映射：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, count = dma_map_sg(dev, sglist, nents, direction);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span>, *<span class="title">sg</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_sg(sglist, sg, count, i) &#123;</span><br><span class="line">    hw_address[i] = sg_dma_address(sg);</span><br><span class="line">  	hw_len[i] = sg_dma_len(sg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，nents是sglist中地址的个数。</p>
<p>dma_map_sg函数的具体实现，可以将多个sglist项映射成1个DMA映射地址，并且返回映射后的实际地址个数，如果出错的话，则返回0。这对于不能处理scatter-gather或者能够处理的scatter-gather中地址项数有限的硬件来说，是十分有帮助的。</p>
<p>如上suoshu，返回的count一定小于等于nents的值。</p>
<p>如果要释放scatterlist的DMA映射，只需要调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_sg(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，dma_unmap_sg传入的参数nents，与dma_map_sg传入的nents值需要相同，而非dma_map_sg返回的实际映射出来的DMA地址个数。</p>
<p>另外，用完DMA映射后，一定要进行unmap。否则会造成资源泄露。</p>
<p>在使用流式DMA映射地址时，一定要注意数据的同步，以保证CPU或者设备能够看到最新的、正确的数据。处理不好的话，很容易引起数据不一致的问题。</p>
<p>一般的操作流程为：使用dma_map{single, sg}()进行DMA映射，然后每次DMA传输完成后，使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_single_for_cpu(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_sg_for_cpu(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>来进行一次同步，以便让CPU获取最新的数据。</p>
<p>然后，如果想让设备获得DMA区域，在将权限交给硬件之前，调用如下的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_single_for_device(dev, dma_handle, size, direction);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dma_sync_sg_for_device(dev, sglist, nents, direction);</span><br></pre></td></tr></table></figure>

<p>最后传输完成后，调用相应的unmap API进行DMA资源的释放。如果在整个传输过程中，我们压根不访问数据，就不需要调用dma_sync_*()相关的API。</p>
<p>下面是使用了dma_sync_*()接口的一份伪代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">my_card_setup_receive_buffer(struct my_card *cp, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> mapping;</span><br><span class="line">  mapping = dma_map_single(cp-&gt;dev, buffer, len, DMA_FROM_DEVICE);</span><br><span class="line">  <span class="keyword">if</span> (dma_mapping_error(cp-&gt;dev, mapping))&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * reduce current DMA mapping usage,</span></span><br><span class="line"><span class="comment">       * delay and try again later or</span></span><br><span class="line"><span class="comment">       * reset driver.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">goto</span> map_error_handling;</span><br><span class="line">  &#125;</span><br><span class="line">  cp-&gt;rx_buf = buffer;</span><br><span class="line">  cp-&gt;rx_len = len;</span><br><span class="line">  cp-&gt;rx_dma = mapping;</span><br><span class="line">  </span><br><span class="line">  give_rx_buf_to_card(cp); </span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">my_card_interrupt_handler(<span class="keyword">int</span> irq, <span class="keyword">void</span> *devid, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_card</span> *<span class="title">cp</span> = <span class="title">devid</span>;</span></span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">if</span> (read_card_status(cp) == RX_BUF_TRANSFERRED) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_card_header</span> *<span class="title">hp</span>;</span></span><br><span class="line">    <span class="comment">/* Examine the header to see if we wish</span></span><br><span class="line"><span class="comment">     * to accept the data. But synchronize</span></span><br><span class="line"><span class="comment">     * the DMA transfer with the CPU first</span></span><br><span class="line"><span class="comment">     * so that we see updated contents.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dma_sync_single_for_cpu(&amp;cp-&gt;dev,</span><br><span class="line">                            cp-&gt;rx_dma,</span><br><span class="line">                            cp-&gt;rx_len,</span><br><span class="line">                            DMA_FROM_DEVICE);</span><br><span class="line">    <span class="comment">/* Now it is safe to examine the buffer. */</span></span><br><span class="line">    hp = (struct my_card header *)cp-&gt;rx_buf;</span><br><span class="line">    <span class="keyword">if</span> (header_is_ok(hp)) &#123;</span><br><span class="line">      dma_unmap_single(&amp;cp-&gt;dev, cp-&gt;rx_dma, cp-&gt;rx_len, DMA_FROM_DEVICE);</span><br><span class="line">      pass_to_upper_layers(cp-&gt;buf);</span><br><span class="line">      make_and_setup_new_rx_buf(cp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* CPU should not write to </span></span><br><span class="line"><span class="comment">         * DMA_FROM_DEVICE-mapped area,</span></span><br><span class="line"><span class="comment">         * so dma_sync_single_for_device() is</span></span><br><span class="line"><span class="comment">         * not needed here. It would be required</span></span><br><span class="line"><span class="comment">         * for DMA_BIDRECTIONAL mapping if</span></span><br><span class="line"><span class="comment">         * the memory was modified.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      give_rx_buf_to_card(cp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次提醒，驱动不应该再使用virt_to_bus()和bus_to_virt()接口了。linux主线后续将会移除这两类的接口</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>DMA资源是有限的，当发生错误时，一定要进行相应的异常处理：</p>
<ul>
<li>查看dma_alloc_coherent()是否返回了NULL或者dma_map_sg返回了0</li>
<li>使用dma_mapping_error()来检查dma_map_single()和dma_map_page()返回的dma_addr_t是否有效</li>
</ul>
<p>多次申请DMA，但是在中间某次申请失败的话，前面成功申请的都需要去释放。</p>
<p>在网卡设备中，发送时申请DMA地址失败后，在ndo_start_xmit的hook函数中，需要调用dev_kfree_skb()进行socket资源的释放并且返回NETDEV_TO_OK。</p>
<p>而对于SCSI设备，则需要返回SCSI_MLQUEUE_HOST_BUSY。在以后的某些时刻，SCSI子系统会再次向驱动下发命令。</p>
<h2 id="优化为了unmap而多出来的状态空间开销"><a href="#优化为了unmap而多出来的状态空间开销" class="headerlink" title="优化为了unmap而多出来的状态空间开销"></a>优化为了unmap而多出来的状态空间开销</h2><p>在许多平台上，dma_unmap_(single, page) 实际上什么都不执行，仅相当于一个nop指令。跟踪映射的地址和长度是十分消耗空间的。为了避免在驱动代码中多了很多if define的语句。可以使用如下的方式来减少空间。</p>
<ul>
<li>使用DEFINE_DMA_UNMAP_{ADDR, LEN}来进行结构体的定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ring_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> mapping;</span><br><span class="line">  __u32 len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ring_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sk_buffer</span> *<span class="title">skb</span>;</span></span><br><span class="line">  DEFINE_DMA_UNMAP_ADDR(mapping);</span><br><span class="line">  DEFINE_DMA_UNMAP_LEN(len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用函数来对mapping和len的字段进行赋值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_addr_set(ringqp, mapping, FOO);</span><br><span class="line">dma_unmap_len_set(ringqp, len, BAR);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用dma_unmap_{addr, len}()进行资源释放：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dma_unmap_single(dev,</span><br><span class="line">                dma_unmap_addr(ringp, mapping),</span><br><span class="line">                dma_unmap_len(ringp, len),</span><br><span class="line">                DMA_FROM_DEVICE);</span><br></pre></td></tr></table></figure>

<h2 id="平台相关的一些主题"><a href="#平台相关的一些主题" class="headerlink" title="平台相关的一些主题"></a>平台相关的一些主题</h2><ul>
<li>如果平台支持IOMMU（包括软件的IOMMU），则内核编译时，需要是能CONFIG_NEED_SG_DMA_LENGTH</li>
<li>ARCH_DMA_MINALIGN</li>
</ul>
<p>架构必须保证kmalloc申请的buffer是DMA安全的。驱动和子系统都依赖于这一点。如果某个平台不是完全DMA一致（比如硬件不能保证在CPU cache中的数据和主存中的数据一致），ARCH_DMA_MINALIGN必须被设置上，以便时内存分配器能够保证kmalloc分配的buffer没有共享cacheline。可以查看一个例子：arch/arm/include/asm/cache.h</p>
<p>需要注意的是，ARCH_DMA_MINALIGN是关于DMA内存对齐的约束。我们不需要关心普通数据的对齐一致性问题。</p>
<p>（Done）</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/DMA/" rel="tag"># DMA</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="tag"># 学习总结</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/03/21/0022-wireshark-bugs-list/" rel="prev" title="Wireshark的一些bug记录">
      <i class="fa fa-chevron-left"></i> Wireshark的一些bug记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/10/15/0024-SSE-AVX-summary/" rel="next" title="Intel的扩展指令集">
      Intel的扩展指令集 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA相关的API"><span class="nav-number">1.</span> <span class="nav-text">DMA相关的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存的DMA可用性"><span class="nav-number">2.</span> <span class="nav-text">内存的DMA可用性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA地址的限制"><span class="nav-number">3.</span> <span class="nav-text">DMA地址的限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两种类型的DMA映射"><span class="nav-number">4.</span> <span class="nav-text">两种类型的DMA映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性DMA映射（consistent-DMA）"><span class="nav-number">4.1.</span> <span class="nav-text">一致性DMA映射（consistent DMA）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流式DMA映射"><span class="nav-number">4.2.</span> <span class="nav-text">流式DMA映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用一致性DMA映射"><span class="nav-number">5.</span> <span class="nav-text">使用一致性DMA映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA方向"><span class="nav-number">6.</span> <span class="nav-text">DMA方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用流式DMA映射"><span class="nav-number">7.</span> <span class="nav-text">使用流式DMA映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理"><span class="nav-number">8.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化为了unmap而多出来的状态空间开销"><span class="nav-number">9.</span> <span class="nav-text">优化为了unmap而多出来的状态空间开销</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平台相关的一些主题"><span class="nav-number">10.</span> <span class="nav-text">平台相关的一些主题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chenny Chen</p>
  <div class="site-description" itemprop="description">码农的午后抒怀</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Seitran" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Seitran" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/2142966741" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2142966741" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenny Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
